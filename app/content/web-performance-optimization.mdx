export const metadata = {
  title: "Web Performance Optimization: A Practical Guide",
  description: "Learn practical techniques to improve your website's performance and user experience.",
  author: "Riku Rainio",
  date: "2024-11-28",
  tags: ["Performance", "Web Development", "Optimization"],
  readTime: "15 min read"
}

# Web Performance Optimization: A Practical Guide

Web performance is crucial for user experience and SEO. In this comprehensive guide, we'll explore practical techniques to optimize your website's performance.

## Why Performance Matters

Performance directly impacts:
- **User Experience**: Faster sites keep users engaged
- **SEO Rankings**: Google uses Core Web Vitals as ranking factors
- **Conversion Rates**: Every second of delay can cost conversions
- **Bounce Rates**: Slow sites have higher bounce rates

## Core Web Vitals

Google's Core Web Vitals measure real-world user experience:

### Largest Contentful Paint (LCP)

LCP measures loading performance. Aim for **< 2.5 seconds**.

**Optimization techniques:**
- Optimize images (use WebP, proper sizing)
- Minimize render-blocking resources
- Use CDN for static assets
- Implement server-side rendering

### First Input Delay (FID)

FID measures interactivity. Aim for **< 100 milliseconds**.

**Optimization techniques:**
- Reduce JavaScript execution time
- Break up long tasks
- Use code splitting
- Defer non-critical JavaScript

### Cumulative Layout Shift (CLS)

CLS measures visual stability. Aim for **< 0.1**.

**Optimization techniques:**
- Set dimensions for images and videos
- Avoid inserting content above existing content
- Use CSS aspect-ratio
- Reserve space for ads and embeds

## Image Optimization

Images are often the largest assets on a page. Here's how to optimize them:

### Use Modern Formats

```html
<picture>
  <source srcset="image.avif" type="image/avif">
  <source srcset="image.webp" type="image/webp">
  <img src="image.jpg" alt="Description">
</picture>
```

### Lazy Loading

```html
<img src="image.jpg" loading="lazy" alt="Description">
```

### Responsive Images

```html
<img 
  srcset="small.jpg 480w, medium.jpg 768w, large.jpg 1200w"
  sizes="(max-width: 768px) 100vw, 50vw"
  src="medium.jpg"
  alt="Description"
>
```

## JavaScript Optimization

### Code Splitting

Split your JavaScript into smaller chunks:

```typescript
// Dynamic import
const HeavyComponent = React.lazy(() => import('./HeavyComponent'))

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <HeavyComponent />
    </Suspense>
  )
}
```

### Tree Shaking

Remove unused code:

```typescript
// Bad: imports entire library
import _ from 'lodash'

// Good: imports only what you need
import debounce from 'lodash/debounce'
```

### Minification and Compression

- Use build tools to minify JavaScript
- Enable gzip or Brotli compression on your server
- Remove source maps in production

## CSS Optimization

### Critical CSS

Inline critical CSS in the `<head>`:

```html
<head>
  <style>
    /* Critical above-the-fold CSS */
    .header { ... }
    .hero { ... }
  </style>
  <link rel="stylesheet" href="main.css" media="print" onload="this.media='all'">
</head>
```

### Remove Unused CSS

Use tools like PurgeCSS to remove unused styles:

```javascript
// purgecss.config.js
module.exports = {
  content: ['./src/**/*.{js,jsx,ts,tsx}'],
  css: ['./src/**/*.css']
}
```

## Caching Strategies

### Browser Caching

Set appropriate cache headers:

```nginx
# Nginx example
location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
  expires 1y;
  add_header Cache-Control "public, immutable";
}
```

### Service Workers

Implement service workers for offline support and caching:

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => response || fetch(event.request))
  )
})
```

## Database and API Optimization

### Query Optimization

- Use indexes on frequently queried fields
- Limit the number of database queries
- Use pagination for large datasets
- Implement database connection pooling

### API Response Optimization

- Return only necessary data
- Use compression (gzip/Brotli)
- Implement response caching
- Use GraphQL for flexible queries

## Monitoring and Measurement

### Tools for Performance Monitoring

1. **Lighthouse** - Built into Chrome DevTools
2. **WebPageTest** - Detailed performance analysis
3. **Google PageSpeed Insights** - Real-world performance data
4. **Chrome DevTools Performance Tab** - Profile runtime performance

### Real User Monitoring (RUM)

Track performance metrics from real users:

```javascript
// Measure LCP
new PerformanceObserver((list) => {
  const entries = list.getEntries()
  const lastEntry = entries[entries.length - 1]
  console.log('LCP:', lastEntry.renderTime || lastEntry.loadTime)
}).observe({ entryTypes: ['largest-contentful-paint'] })
```

## Best Practices Checklist

- [ ] Optimize images (WebP, proper sizing, lazy loading)
- [ ] Minimize JavaScript bundle size
- [ ] Implement code splitting
- [ ] Remove unused CSS
- [ ] Enable compression (gzip/Brotli)
- [ ] Set appropriate cache headers
- [ ] Minimize render-blocking resources
- [ ] Use CDN for static assets
- [ ] Implement server-side rendering where appropriate
- [ ] Monitor Core Web Vitals

## Conclusion

Performance optimization is an ongoing process. Start by measuring your current performance, identify bottlenecks, and implement optimizations systematically. Remember: small improvements can have a significant impact on user experience and business metrics.

Focus on the metrics that matter most to your users and business goals, and continuously monitor and improve your site's performance.

